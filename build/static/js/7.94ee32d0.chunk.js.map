{"version":3,"sources":["utils/uriToHttp.ts","state/lists/getTokenList.ts"],"names":["uriToHttp","uri","split","toLowerCase","substring","hash","match","name","tokenListValidator","Ajv","allErrors","compile","schema","getTokenList","listUrl","urls","i","length","url","isLast","response","fetch","console","error","Error","ok","json","validationErrors","errors","reduce","memo","add","dataPath","message"],"mappings":"4zQAKe,SAASA,EAAUC,GAAwB,IAAD,IAErD,OADiBA,EAAIC,MAAM,KAAK,GAAGC,eAE/B,IAAK,QACD,MAAO,CAACF,GACZ,IAAK,OACD,MAAO,CAAC,QAAD,OAASA,EAAIG,UAAU,IAAMH,GACxC,IAAK,OACD,IAAMI,EAAuC,QAAnC,EAAGJ,EAAIK,MAAM,8BAAsB,aAAhC,EAAmC,GAChD,MAAO,CAAC,oCAAD,OAAqCD,EAAI,oCAA6BA,EAAI,MACrF,IAAK,OACD,IAAME,EAAuC,QAAnC,EAAGN,EAAIK,MAAM,8BAAsB,aAAhC,EAAmC,GAChD,MAAO,CAAC,oCAAD,OAAqCC,EAAI,oCAA6BA,EAAI,MACrF,QACI,MAAO,GAEnB,C,iCCdaC,EAAqB,IAAIC,IAAI,CAAEC,WAAW,IAAQC,QAAQC,GAMxD,SAAeC,EAAa,GAAD,+BAgCzC,sDAhCc,WAA4BC,GAAe,iGAChDC,EAAiBf,EAAUc,GAExBE,EAAI,EAAE,KAAD,OAAEA,EAAID,EAAKE,QAAM,iBAGf,OAFNC,EAAMH,EAAKC,GACXG,EAASH,IAAMD,EAAKE,OAAS,EAC/BG,OAAQ,oBAESC,MAAMH,GAAI,OAA3BE,EAAQ,+BAE6C,GAF7C,0BAERE,QAAQC,MAAM,uBAAwBT,EAAQ,EAAD,KACzCK,EAAO,CAAD,sBAAQ,IAAIK,MAAM,2BAAD,OAA4BV,IAAU,kDAIhEM,EAASK,GAAG,CAAD,oBACRN,EAAO,CAAD,sBAAQ,IAAIK,MAAM,2BAAD,OAA4BV,IAAU,gEAIlDM,EAASM,OAAM,QAAxB,GAAJA,EAAI,OACLlB,EAAmBkB,GAAM,CAAD,gBAKI,MAJvBC,EAII,QAJoB,EACD,QADC,EAC1BnB,EAAmBoB,cAAM,aAAzB,EAA2BC,QAAe,SAACC,EAAMP,GAAW,IAAD,EACjDQ,EAAG,UAAOR,EAAcS,SAAQ,YAAiB,QAAjB,EAAIT,EAAMU,eAAO,QAAI,IAC3D,OAAOH,EAAKb,OAAS,EAAC,UAAMa,EAAI,aAAKC,GAAG,UAAQA,EACpD,GAAG,WAAG,QAAI,gBACR,IAAIP,MAAM,iCAAD,OAAkCG,IAAmB,iCAEjED,GAAI,QA1BkBV,IAAG,6BA4B9B,IAAIQ,MAAM,mCAAkC,2DACrD,sB","file":"static/js/7.94ee32d0.chunk.js","sourcesContent":["/* eslint-disable no-case-declarations */\r\n/**\r\n * Given a URI that may be ipfs, ipns, http, or https protocol, return the fetch-able http(s) URLs for the same content\r\n * @param uri to convert to fetch-able http url\r\n */\r\nexport default function uriToHttp(uri: string): string[] {\r\n    const protocol = uri.split(':')[0].toLowerCase()\r\n    switch (protocol) {\r\n        case 'https':\r\n            return [uri]\r\n        case 'http':\r\n            return [`https${uri.substring(4)}`, uri]\r\n        case 'ipfs':\r\n            const hash = uri.match(/^ipfs:(\\/\\/)?(.*)$/i)?.[2]\r\n            return [`https://cloudflare-ipfs.com/ipfs/${hash}/`, `https://ipfs.io/ipfs/${hash}/`]\r\n        case 'ipns':\r\n            const name = uri.match(/^ipns:(\\/\\/)?(.*)$/i)?.[2]\r\n            return [`https://cloudflare-ipfs.com/ipns/${name}/`, `https://ipfs.io/ipns/${name}/`]\r\n        default:\r\n            return []\r\n    }\r\n}\r\n","/* eslint-disable no-continue */\r\n/* eslint-disable no-await-in-loop */\r\nimport { TokenList } from 'src/utils/token'\r\nimport uriToHttp from 'src/utils/uriToHttp'\r\nimport Ajv from 'ajv'\r\nimport schema from './svcswap.json'\r\n\r\nexport const tokenListValidator = new Ajv({ allErrors: true }).compile(schema)\r\n\r\n/**\r\n * Contains the logic for resolving a list URL to a validated token list\r\n * @param listUrl list url\r\n */\r\nexport default async function getTokenList(listUrl: string): Promise<TokenList> {\r\n    const urls: string[] = uriToHttp(listUrl)\r\n\r\n    for (let i = 0; i < urls.length; i++) {\r\n        const url = urls[i]\r\n        const isLast = i === urls.length - 1\r\n        let response\r\n        try {\r\n            response = await fetch(url)\r\n        } catch (error) {\r\n            console.error('Failed to fetch list', listUrl, error)\r\n            if (isLast) throw new Error(`Failed to download list ${listUrl}`)\r\n            continue\r\n        }\r\n\r\n        if (!response.ok) {\r\n            if (isLast) throw new Error(`Failed to download list ${listUrl}`)\r\n            continue\r\n        }\r\n\r\n        const json = await response.json()\r\n        if (!tokenListValidator(json)) {\r\n            const validationErrors: string =\r\n                tokenListValidator.errors?.reduce<string>((memo, error) => {\r\n                    const add = `${(error as any).dataPath} ${error.message ?? ''}`\r\n                    return memo.length > 0 ? `${memo}; ${add}` : `${add}`\r\n                }, '') ?? 'unknown error'\r\n            throw new Error(`Token list failed validation: ${validationErrors}`)\r\n        }\r\n        return json as TokenList\r\n    }\r\n    throw new Error('Unrecognized list URL protocol.')\r\n}\r\n"],"sourceRoot":""}